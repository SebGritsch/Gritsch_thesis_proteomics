---
title: "Master's Thesis: Analysis of Sarracenia proteomic data"
author: "Sebastian Gritsch"
date: "2023-11-14"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r initialize_project}
here::i_am("notebooks/thesis_analysis_sarracenia.rmd")
```

```{r load libraries}
library(here)
library(tidyverse)
library(Biobase)
library(magrittr)
library(limma)
library(pheatmap)
library(ggfortify)
library(EnhancedVolcano)
```

### Generate manifest file for FragPipe

```{r generate fragpipe manifest, eval = FALSE}
# Get list of mzML files with full path names
ms_data_dir <- here("data", "ms_data", "mzml")
ms_files <- list.files(ms_data_dir, pattern = "mzML", full.names = TRUE)

# create data frame for fragpipe manifest
# extract experiments (condition_time) from file names 
fp_manifest <- data.frame(file = ms_files, stringsAsFactors = FALSE) %>%
  mutate(experiment = str_extract(file, "N_[A-Z]_t[0-5]"),
         # extract bioreplicates from file names
         bioreplicate = gsub(".mzML", "", str_extract(file, "[1-3].mzML$")),
         # add column with data type "DDA"
         data_type = "DDA") %>%
  # select rows where experiment is not NA
  filter(!is.na(experiment)) %>%
  set_colnames(c("file", "experiment", "bioreplicate", "data_type"))

# export tab separated file with the name "nepenthes.fp-manifest"
write.table(fp_manifest, file = here("data" ,"nepenthes.fp-manifest"),
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# repeat for sarracenia
fp_manifest <- data.frame(file = ms_files, stringsAsFactors = FALSE) %>%
  mutate(experiment = str_extract(file, "S_[A-Z]_t[0-5]"),
         bioreplicate = gsub(".mzML", "", str_extract(file, "[1-3].mzML$")),
         data_type = "DDA") %>%
  filter(!is.na(experiment)) %>%
  set_colnames(c("file", "experiment", "bioreplicate", "data_type"))

write.table(fp_manifest, file = here("data", "sarracenia.fp-manifest"),
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```


### Define colors

Colors are based on color friendly palettes from Martin Krzywinski: Krzywinski, M. Designing for Color Blindess - Martin Krzywinski / Genome Sciences Center. <http://mkweb.bcgsc.ca/colorblind/index.mhtml#page-container>

```{r define colors}
colors <- list(
  CONDITION = c("A" = "#9F0162", "B" = "#C7007C", "C" = "#FF5AAF", "D" = "#005FCC",
                "E" = "#007702", "F" = "#EF0096", "G" = "#0079FA", "H" = "#009503",
                "I" = "#00C2F9", "J" = "#00D302", "K" = "#00E5F8", "L" = "#00F407",
                "M" = "#009FFA", "N" = "#00B408", "O" = "#7CFFFA", "P" = "#AFFF2A",
                "Q" = "#FFCFE2"),
  PLASTIC = c("PET" = "#00C2F9", "PBAT" = "#00F407", "no" = "#FF5AAF"),
  JASMONATE = c("+" = "#FF9DC8", "-" = "#FFCFE2"),
  WORM = c("dry" = "#CD022D", "live" = "#FF6E3A", "no" = "#FFDC3D"),
  TIME = c("t0" = "#FFCCFE", "t1" = "#FF92FD", "t3" = "#8400CD", "t5" = "#450270")
)

# Color range for heatmaps for DE analysis
# Define breaks for logFCo from -10 to 10 by 0.2
breaks = seq(-10, 10, by = 0.2)
colors_heatmap <- colorRampPalette(
  rev(RColorBrewer::brewer.pal(n = 7,name = "RdYlBu")))(length(breaks))

```
### Function definitions

```{r helper functions}

# Function to get annotated data frame in long format
join_long <- function(eset) {
  exprs(eset) %>%
  as.data.frame() %>%
  pivot_longer(cols =everything(), names_to ="SAMPLEID", values_to ="value") %>%
  left_join(., pData(eset), by = "SAMPLEID")
}

plot_mean_sd <- function(eset, main = NULL) {
  # Create a mean vs. CV^2 plot with a loess trend line
  # Code was adapted from the msImpute package
  data <- exprs(eset) %>%
    as.data.frame() %>%
    rowwise() %>%
    mutate(mean = mean(c_across(everything()), na.rm = TRUE),
           CV = (sd(c_across(everything()), na.rm = TRUE)/mean)^2) %>%
    ungroup()
  
  fit <- limma::loessFit(data$CV, data$mean)
  data$fitted <- fit$fitted
  
  p <- ggplot(data, aes(x = mean, y = CV)) +
    geom_point(size = 0.4) +
    labs(x = "Average log-intensity", y = expression("CV"^2), title = main) +
    geom_line(aes(y = fitted), color = "red", size = 0.75) +
    theme_classic() +
    theme(plot.title = element_text(size = 9),
          axis.title = element_text(size = 9))


  return(p)
}

plot_missing_values_heatmap <- function(eset){
  # Set distance between column names and heatmap
  ComplexHeatmap::ht_opt("COLUMN_ANNO_PADDING" = unit(0, "mm"))
  
  # column annotation
  col_annotation = eset %>%
    exprs(.) %>%
    colnames(.) %>%
    str_extract(., "t[0-5]") %>%
    ComplexHeatmap::HeatmapAnnotation(Time = .,
                                      col = list(Time = colors$TIME),
                                      simple_anno_size = unit(2, "mm"),
                                      gp = grid::gpar(col = "black"),
                                      show_annotation_name = FALSE,
                                      annotation_legend_param = list(
                                        nrow = 1,
                                        title_position = "lefttop",
                                        title_gp = grid::gpar(fontsize = 8),
                                        labels_gp = grid::gpar(fontsize = 8),
                                        grid_height = unit(3, "mm"),
                                        grid_width = unit(3, "mm")))
  
  # Plot a heatmap of proteins with missing values
  # code adapted from the plot_missval() function of the DEP package
  heatmap <- eset %>%
    exprs(.) %>%
    data.frame(.) %>%
    # convert missing values to 0 and valid values to 1
    mutate_all(~ifelse(is.na(.), 0, 1)) %>%
    # create a heatmap
    ComplexHeatmap::Heatmap(col = c("white", "black"),
            cluster_columns = FALSE,
            column_names_side = "top",
            show_row_names = FALSE,
            top_annotation = col_annotation,
            show_column_names = TRUE,
            # Simplify column names
            column_labels = str_replace(colnames(.), "^[NS]_", "") %>% 
              str_replace("_t[0-5]_[0-3]", ""),
            column_names_gp = grid::gpar(fontsize = 5),
            column_names_centered = TRUE,
            show_row_dend = FALSE,
            name = "Value",
            heatmap_legend_param = list(at = c(0, 1),
                                        labels = c("Missing", "Observerd"),
                                        title_position = "lefttop",
                                        title_gp = grid::gpar(fontsize = 8),
                                        labels_gp = grid::gpar(fontsize = 8),
                                        grid_height = unit(3, "mm"),
                                        grid_width = unit(3, "mm"),
                                        border = "black",
                                        nrow = 1),
            border_gp = grid::gpar(col = "black", lwd = 1.5),
            column_names_rot = 00) %>%  
    # Draw heatmap
    ComplexHeatmap::draw(heatmap_legend_side = "top",
                         annotation_legend_side = "top") 
  
  return(heatmap)
}

plot_heatmap <- function(toptable, annotation = NULL, FC = 0, title = NA,
                         cluster_cols = TRUE, cluster_rows = TRUE, font = 8,
                         treeheight_col = 30, treeheight_row = 30){
  # make heatmap of top proteins
  
  # toptable: top table from limma
  # annotation: vector with variables of metadata to include in the heatmap
  # FC: fold change cutoff
  # font: font size of the heatmap
  # title: title of the heatmap
  # cluster_cols: cluster columns; Boolean
  # cluster_rows: cluster rows; Boolean
  # treeheight_col: height of the column tree in points
  # treeheight_row: height of the row tree in points
  
  # Create column annotation for heatmap
  if (!is.null(annotation)){
    col_annotation <- toptable %>%
      select(matches("_vs_")) %>%
      colnames() %>%
      unique() %>%
      data.frame(Contrast = .) %>%
      mutate(TIME = str_extract(Contrast, "t[0-5]"),
             CONDITION = str_extract(Contrast, "^[A-Z]")) %>%
      # add condition metadata
      left_join(metadata, by = c("CONDITION" = "CONDITION")) %>%
      # convert true and false to + - for better visualization
      mutate(JASMONATE = ifelse(JASMONATE, "+", "-")) %>%
      select(Contrast, annotation) %>%
      column_to_rownames("Contrast") 
  } else {
    col_annotation <- NA
  }
  
  column_names <- toptable %>%
    # select contrasts
    select(matches("_vs_")) %>%
    # replace "_" in column names with blank
    colnames() %>%
    str_replace_all("_vs_", " vs. ") %>%
    str_remove_all("_t[0-5]")

  plot <- toptable %>%
    # select contrasts
    select(matches("_vs_")) %>%
    # remove row if all values are NA
    filter(if_any(everything(), ~ !is.na(.))) %>%
    # set NA to 0
    mutate_all(~replace_na(., 0)) %>%
    # filter for proteins with a logFC > FC in at least one contrast
    filter(rowSums(abs(.) > FC) >0) %>%
    # plot heatmap
    pheatmap(scale = "none",
             cluster_cols = cluster_cols,
             cluster_rows = cluster_rows,
             treeheight_col = treeheight_col,
             treeheight_row = treeheight_row,
             labels_col = column_names,
             labels_row = toptable$Protein.ID,
             show_rownames = FALSE,
             # aesthetics
             fontsize = font,
             border_color = NA,
             annotation_col = col_annotation,
             annotation_colors = colors,
             main = title,
             color = colors_heatmap,
             breaks = breaks)
  
  return(plot)
}

count_deregulated_proteins <- function(toptable, FC = 0, sort = "up"){
  # Create table with the number of deregulated proteins
  
  # toptable: top table from limma
  # FC: fold change cutoff
  # sort: "up" or "down" to sort by up- or downregulated proteins
  
  df <- toptable %>%
    select(matches("_VS_", ignore.case = TRUE)) %>%
    # count number of proteins that are up- and downregulated per contrast
    rbind("up" = summarise_all(., ~sum(. > FC, na.rm = TRUE)),
          "down" = summarise_all(., ~sum(. < -FC, na.rm = TRUE))) %>%
    # only keep rows with the new metrics
    filter(row.names(.) %in% c("up", "down")) %>%
    # transpose for better readability
    t() %>%
    data.frame() %>%
    # reorder columns
    arrange(if (tolower(sort) == "down") desc(down) else desc(up))
  return(df)
}

identify_deregulated_proteins <- function(toptable, FC = 0, DE = "up",
                                          cutoff = 0, min_present = 20) {
  # calculates the percentage of differential expression (either up or down)
  # in the contrasts where the protein is present.
  # Adds column "overexpressed" or "underexpressed" and sorts by the highest number
  # Adds column "present" indicating the % of contrasts the protein is present in
  
  # toptable: top table from limma
  # FC: fold change cutoff
  # cutoff: cutoff for the % of contrasts in which a protein is overexpressed
  # min_present: minimum % of contrasts a protein has to be present in
  # DE: up or downregulated ["up", "down"]
  
  # Validate DE input
  assertthat::assert_that(DE %in% c("up", "down"),
                          msg = "DE must be either 'up' or 'down'")
  
  # Determine the direction of regulation
  comparison <- if (DE == "up") function(x) x > FC else function(x) x < -FC
  expression_column <- if (DE == "up") "overexpressed" else "underexpressed"
  
  num_contrasts <- length(grep("_vs_", colnames(toptable)))
  
  df <- toptable %>%
    mutate(across(matches("_vs_"), ~ifelse(comparison(.), 1, 0))) %>%
    mutate(
      # Count the number of contrasts a protein is present in (not NA)
      present_num = rowSums(!is.na(select(., matches("_vs_")))),
      # Calculate the % of contrasts a protein is present in
      present = 100 * present_num / num_contrasts,
      # Calculate the % of contrasts a protein is differentially expressed in
      !!expression_column := 100 * rowSums(select(., matches("_vs_")), na.rm = TRUE) / present_num
    ) %>%
    # Filter proteins based on cutoff and minimum presence
    filter(get(expression_column) >= cutoff & present >= min_present) %>%
    select(Protein.ID, !!expression_column, present) %>%
    # Join with toptable to get the original logFC values and metadata
    left_join(toptable, by = "Protein.ID") %>%
    select(-adj.P.Val) %>%
    # Sort by % of differentially expressedion in contrasts
    arrange(desc(get(expression_column)))
  
  return(df)
}

extract_pvalue <- function(results, contrasts, protein_ids){
  # extract adjusted p-values and lod2FC of query proteins from given contrasts
  
  # results: list of limma results for each contrast
  # protein_ids: vector of protein ids
  
  # create temporary list to store dataframes
  temp_list <- list()
  # extract data for each contrast
  for(contrast in contrasts){
    temp_df <- results[[contrast]] %>%
      filter(Protein.ID %in% protein_ids) %>%
      mutate(Contrast = contrast) %>%
      select(Protein.ID, Description, Contrast, P.Value, adj.P.Val, logFC)
    # remove rownames to avoid duplicates
    rownames(temp_df) <- NULL
    # add dataframe to list
    temp_list[[contrast]] <- temp_df
    }
  # combine all dataframes
  temp_df <- bind_rows(temp_list)
  return(temp_df)
}


save_pheatmap_png <- function(x, filename, width=16, height=9, res = 300,
                              units = "cm") {
  # function to save pheatmap as png
  
  # x: pheatmap object
  # filename: name of the file to save
  # width: width of the plot
  # height: height of the plot
  # res: resolution of the plot
  # units: units of the plot dimensions
  
  png(filename, width = width, height = height, res = res, units = units)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}

plot_volcano <- function(results, name, FC = 2, p.val = 0.05, lab = TRUE) {
  # Define function to plot volcano plot from results list with given contrast name
  
  # results: list of limma results for each contrast
  # name: name of the contrast to plot
  # FC: fold change cutoff
  # p.val: p-value cutoff
  # lab: logical indicating if putative degraders should be labeled
  
  data <- results[[name]]
  
  label <- if(exists("putative_degraders") & isTRUE(lab)){
    putative_degraders$Description} else {NULL}
    
  # Check if there are any results
  if (sum(data$logFC, na.rm = TRUE) == 0) {
    print(paste("No results found for contrast", name))
  }
  else {
    # Create volcano plot
    plot <- data %>%
      # filter out NA values
      filter(!is.na(.[["logFC"]])) %>%
      # plot volcano plot
      EnhancedVolcano(.,
                      lab = .$Description,
                      drawConnectors = TRUE,
                      max.overlaps = 10,
                      maxoverlapsConnectors = 15,
                      labSize = 2.0,
                      selectLab = label,
                      x = "logFC",
                      xlab = bquote("log"[2]~"FC"),
                      xlim = c(-max(abs(.$logFC)), max(abs(.$logFC))),
                      FCcutoff = FC,
                      y = "adj.P.Val",
                      ylab = bquote("-log"[10] ~ "adj. p-value"),
                      titleLabSize = 11,
                      axisLabSize = 11,
                      captionLabSize = 10,
                      legendLabSize = 11,
                      legendIconSize = 3,
                      pCutoff = p.val,
                      #ylim = c(0, max(-log10(.[["adj.P.Val"]]), na.rm = TRUE) + 2),
                      ylim = c(0, 8),
                      col = c("grey30", "#4575B4","#FEE090", "#D73027"),
                      title = name %>% str_replace_all("vs", " vs. ") %>% str_replace_all("_", " "),
                      subtitle = "",
                      caption = paste0("total = ", nrow(.), " proteins"),
                      legendLabels = c("NS",
                                        bquote("|log"[2]~"FC| >" ~ .(FC)),
                                        paste0("adj. p-value < ",p.val),
                                        bquote("|log"[2]~"FC| >" ~ .(FC) ~
                                                 " & adj. p-val. < "~.(p.val)))) +
                                       
  # add vertical line at logFC = 0
  geom_vline(xintercept = 0, linetype = 1, color = "black")

    return(plot)
  }
}

save_plot <- function(plot, filename, format = "png", width = 10, height = 5,
                          units = "cm", res = 300) {
  # function to save non ggplots as png or pdf
  if (format == "png") {
    png(filename, width = width, height = height, units = units, res = res)
  } else if (format == "pdf") {
    pdf(filename, width = width, height = height, onefile = FALSE)
  } else {
    stop("Invalid format")
  }
  print(plot)
  dev.off()
}
```


### Explore FragPipe output


```{r load data}
data_dir <- here("results/sarracenia")

fragpipe_dir <- here(data_dir, "00_fragpipe")

# create directory for results
explore_dir <- here(data_dir, "01_exploration")
dir.create(explore_dir, showWarnings = FALSE)

# Import fragpipe results
data <- rio::import(here(fragpipe_dir, "combined_protein.tsv")) %>%
  # make column names tidy
  rename_with(make.names)


# Import metadata
metadata <- rio::import(here("data/conditions_metadata.csv"))

```

#### Explore difference between Intensity and MaxLFQ Intensity

```{r}
# Extract Intensities from the data
data_int <- data %>%
  # filter out contaminating proteins from cRAP database and trypsin
  filter(!grepl("cRAP[0-9]{3}", Protein)) %>%
  filter(!grepl("cRAP[0-9]{3}", Indistinguishable.Proteins)) %>%
  filter(!grepl("TRY", Entry.Name)) %>%
  # filter rows without Protein ID
  filter(!is.na(Protein.ID)) %>%
  # set Protein.ID as rownames
  column_to_rownames("Protein.ID") %>%
  # select columns with Intensities
  select(ends_with("Intensity"), -contains("MaxLFQ")) %>%
  # Remove 'Intensity' from column names
  set_colnames(., str_replace(colnames(.), ".Intensity", "")) %>%
  log2() %>%
  # convert -Inf to NA
  mutate_all(~ifelse(. == -Inf, NA, .))

# are there samples with only NA values?
data_int %>%
  select(where(~all(is.na(.)))) %>%
  colnames()

# Remove samples with only NA values
data_int <- data_int %>%
  select(where(~!all(is.na(.))))

# Calculate mean Intensity
mean_intensity <- data_int %>%
  select(matches("[NS]_[A-Z]_t[0-5]_[1-3]")) %>%
  rownames_to_column("Protein.ID") %>%
  pivot_longer(names_to = "Sample",
               values_to = "Intensity", -"Protein.ID") %>%
  # add columns for condition and time
  separate_wider_delim(Sample,
                       names = c("Plant", "Condition", "Time", "Replicate"),
                       delim = "_") %>%
  # Calculate the mean intensity for each Condition_Time group
  group_by(Condition, Time, `Protein.ID`) %>%
  summarise(mean_intensity = mean(Intensity)) %>%
  ungroup() %>%
  # add back the sample name
  mutate(Sample = paste(Condition, Time, sep = "_"),
  # convert NA to 0
  mean_intensity = ifelse(is.na(mean_intensity), 0, mean_intensity)) %>%
  # convert back into wide format
  select(-Condition, -Time) %>%
  pivot_wider(names_from = Sample, values_from = mean_intensity) %>%
  column_to_rownames("Protein.ID") %>%
  # fitler out rows with all 0s
  filter(rowSums(.) > 0)

# Create annotation for heatmap
col_annotation <- mean_intensity %>%
  colnames() %>% unique() %>%
  data.frame(Sample = .) %>%
  mutate(Time = str_extract(Sample, "t[0-5]"),
         Condition = str_extract(Sample, "^[A-Z]")) %>%
  column_to_rownames("Sample")

# Create heatmap
mean_intensity %>%
  pheatmap(annotation_col = col_annotation,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = FALSE,
  main = "Mean log2 Intensity",
  fontsize = 5,
  fontsize_col = 8)

# Extract MaxLFQ intensities from the data
data_MaxLFQ <- data %>%
  # filter out contaminating proteins from cRAP database
  filter(!grepl("cRAP[0-9]{3}", Protein)) %>%
  filter(!grepl("cRAP[0-9]{3}", Indistinguishable.Proteins)) %>%
  filter(!grepl("TRY", Entry.Name)) %>%
  # filter rows without Protein ID
  filter(!is.na(Protein.ID)) %>%
  # set Protein.ID as rownames
  column_to_rownames("Protein.ID") %>%
  # select columns with MaxLFQ intensities
  select(ends_with("MaxLFQ.Intensity")) %>%
  # Remove 'Intensity' from column names
  set_colnames(., str_replace(colnames(.), ".MaxLFQ.Intensity", "")) %>%
  log2() %>%
  # convert -Inf to NA
  mutate_all(~ifelse(. == -Inf, NA, .))

# are there samples with only NA values?
data_MaxLFQ %>%
  select(where(~all(is.na(.)))) %>%
  colnames()

# Remove samples with only NA values
data_MaxLFQ <- data_MaxLFQ %>%
  select(where(~!all(is.na(.))))

# Calculate mean MaxLFQ intensity
mean_MaxLFQ <- data_MaxLFQ %>%
  select(matches("[NS]_[A-Z]_t[0-5]_[1-3]")) %>%
  rownames_to_column("Protein.ID") %>%
  pivot_longer(names_to = "Sample",
               values_to = "Intensity", -"Protein.ID") %>%
  # add columns for condition and time
  separate_wider_delim(Sample,
                       names = c("Plant", "Condition", "Time", "Replicate"),
                       delim = "_") %>%
  # Calculate the mean intensity for each Condition_Time group
  group_by(Condition, Time, `Protein.ID`) %>%
  summarise(mean_intensity = mean(Intensity)) %>%
  ungroup() %>%
  # add back the sample name
  mutate(Sample = paste(Condition, Time, sep = "_"),
  # convert NA to 0
  mean_intensity = ifelse(is.na(mean_intensity), 0, mean_intensity)) %>%
  # convert back into wide format
  select(-Condition, -Time) %>%
  pivot_wider(names_from = Sample, values_from = mean_intensity) %>%
  column_to_rownames("Protein.ID") %>%
  # fitler out rows with all 0s
  filter(rowSums(.) > 0)

# Create heatmap
mean_MaxLFQ %>%
  pheatmap(annotation_col = col_annotation,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_rownames = FALSE,
  main = "Mean log2 MaxLFQ Intensity",
  fontsize = 5,
  fontsize_col = 8)

# Summary table of detected proteins when using Intensity and MaxLFQ Intensity
data.frame(row.names = c("Intensity", "MaxLFQ Intensity"),
           # Number of identified proteins
           Num_proteins = c(nrow(data_int), nrow(data_MaxLFQ)),
           # Number of detected proteins across all samples
           Detected = c(sum(data_int > 0, na.rm = TRUE),
                        sum(data_MaxLFQ > 0, na.rm = TRUE)),
           # Missing values across all values
           Missing = c(sum(is.na(data_int)),
                       sum(is.na(data_MaxLFQ))))
```
#### Explore differences between conditions at each time point

```{r}
for (t in unique(col_annotation$Time)) {
  mean_intensity %>%
    select(matches(t)) %>%
    # fitler out rows with all 0s
    filter(rowSums(.) > 0) %>%
    pheatmap(cluster_rows = TRUE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    main = paste("Mean log2 Intensity at", t),
    border_color = NA,
    fontsize = 5)
}
```

#### Number of proteins per sample

```{r}
# dotplot of number of proteins per sample
(data_int %>%
  summarize_all(~sum(!is.na(.))) %>%
  pivot_longer(everything(), names_to = "SAMPLEID", values_to = "num_proteins") %>%
  mutate(FACTOR = str_extract(SAMPLEID, "[A-Z]_t[0-5]"),
         CONDITION = str_split_i(SAMPLEID, "_", 2),
         TIME = str_extract(FACTOR, "t[0-5]") %>%
           str_replace(., "t", "Week ")) %>%
  # add metadata
  left_join(metadata, by = c("CONDITION" = "CONDITION")) %>%
  
  ggplot(.,aes(x = CONDITION, y = num_proteins, fill = CONDITION)) +
  geom_dotplot(binaxis = "y", stackdir = "center", dotsize = 2.0) +
  facet_wrap(~TIME, scales = "free", strip.position = "bottom") +
  labs(y = "Number of proteins") +
  theme_classic() +
  theme(legend.position = "none",
        axis.title = element_text(size = 9),
        axis.text.x = element_text(size = 8, vjust = 0.2),
        axis.title.x = element_blank(),
        strip.background = element_blank(),
        strip.placement = "outside") +
    scale_y_continuous(limits = c(0, 600)) +
  # use colours as defined in "colors" object
  scale_fill_manual(values = colors$CONDITION)
  ) %T>%
  ggsave(plot = ., filename = here(explore_dir, "proteins_per_sample_SAR.png"),
         width = 13, height = 8, units = "cm", dpi = 300)


# Visualise shared proteins between conditions
(data_int %>%
  rownames_to_column(var = "Protein.ID") %>%
  pivot_longer(-Protein.ID, names_to = "SAMPLEID", values_to = "Intensity") %>%
  mutate(CONDITION = str_split_i(SAMPLEID, "_", 2),
         FACTOR = str_extract(SAMPLEID, "[A-Z]_t[0-5]")) %>%
  filter(!is.na(Intensity)) %>%
  group_by(CONDITION) %>%
  summarize(Protein.IDs = list(Protein.ID)) %>%
  deframe() %>%
  UpSetR::fromList() %>%
  UpSetR::upset(.,
                nsets = length(.),
                sets = names(.),
                keep.order = TRUE,
                order.by = "freq",
                sets.x.label = "Proteins per condition",
                mainbar.y.label = "Protein intersection",
                point.size = 1.5,
                mb.ratio = c(0.5, 0.5))
  )%T>%
  save_plot(filename = here(explore_dir, "upset_proteins_per_condition_SAR.png"),
                width = 13, height = 9, res = 300)
```

### Preprocess data

#### Filter data

```{r}
# create directory for results
preprocessing_dir <- here(data_dir, "02_preprocessing")
dir.create(preprocessing_dir, showWarnings = FALSE)
dir.create(here(preprocessing_dir, "plots"), showWarnings = FALSE)
```

```{r import feature and sample annotation}
# Extract protein annotation from fragpipe output 'data'
feature_annotation <- data %>%
  dplyr::select('Protein',
                'Protein.ID',
                'Entry.Name',
                'Gene',
                'Protein.Length',
                'Organism',
                'Protein.Existence',
                'Description',
                'Protein.Probability',
                'Top.Peptide.Probability',
                'Indistinguishable.Proteins') %>%
  mutate(rownames = Protein.ID) %>%
  column_to_rownames('rownames')

# Import sample annotation from fragpipe annotation file
sample_annotation <- rio::import(here(fragpipe_dir, "experiment_annotation.tsv")) %>%
  dplyr::select(sample, condition) %>%
  set_colnames(c("SAMPLEID", "CONDITION")) %>%
  # extract information from sample names using regular expressions
  mutate(CONDITION = gsub("[NS]_", "", str_extract(SAMPLEID, "[NS]_[A-Z]")),
         REPLICATE = gsub("_", "", str_extract(SAMPLEID, "_[1-3]$")),
         TIME = str_extract(SAMPLEID, "t[0-5]"),
         FACTOR = str_extract(SAMPLEID, "[A-Z]_t[0-5]")) %>%
  # add metadata
  left_join(., metadata, by = "CONDITION") %>%
  mutate(rowname = SAMPLEID) %>%
  column_to_rownames()
```

```{r filter data}
# Filter out proteins occuring in less than 66% of replicates of at least one FACTOR (condition_time)
assayData <- data_int %>%
  # convert NA to 0 and integers to 1
  mutate_all(~ifelse(is.na(.), 0, 1)) %>%
  # convert to long format
  rownames_to_column('Protein.ID') %>%
  pivot_longer(-Protein.ID, names_to = "SAMPLEID", values_to = "Intensity") %>%
  # join with sample annotation
  left_join(., sample_annotation, by = "SAMPLEID") %>%
  # calculate missing values per sample triplicate (FACTOR)
  group_by(Protein.ID, FACTOR) %>%
  summarize(n = n(), # number of replicates per protein and FACTOR
            miss_val = n() - sum(Intensity)) %>% # number of missing values
  # fitler out proteins
  filter(miss_val < 2/3*n) %>% # change this value to change threshold
  ungroup() %>%
  # extract Protein.IDs
  pull(Protein.ID) %>%
  # keep unique Protein.IDs
  unique()

# filter out rows that are not in assayData
assayData <- data_int %>%
  filter(rownames(data_int) %in% assayData) %>%
  # remove columns with only NA values
  select(where(~!all(is.na(.))))

# filter out rows with more than 95% missing values
#assayData <- assayData[rowMeans(is.na(assayData)) < 0.95, ]

# print the number of filtered proteins
print(paste("Number of proteins filtered out:", nrow(data_int) - nrow(assayData)))
```
Filtering out proteins with less than 95% missing values did not change the results when extracting the most overexpressed proteins, but the resulting adjusted p-values increased, therefore this step was removed.

```{r construct eset}
# Construct eset
eset <- ExpressionSet(assayData = as.matrix(assayData),
                      phenoData = AnnotatedDataFrame(sample_annotation)[colnames(assayData),],
                      featureData = AnnotatedDataFrame(feature_annotation)[rownames(assayData),])

# Check validity of eset object
validObject(eset)

# Save eset
eset %>% rio::export(here(preprocessing_dir, "eset.RDS"))
```

#### Look for missing values

```{r missing_values_patterns}
plot_missing_values_heatmap(eset) %T>%
  save_plot(here(preprocessing_dir, "plots", "missing_values_patterns.png"),
            width = 16, height = 9, res = 300)
```

How much of the data is missing?

```{r missing_values_percentage}
# Calculate the percentage of missing values per protein
eset %>%
  exprs(.) %>%
  data.frame(.) %>%
  # convert missing values to 0 and valid values to 1
  mutate_all(~ifelse(is.na(.), 0, 1)) %>%
  # calculate the percentage of missing values per protein
  mutate(missing = (1-(rowSums(.)/(ncol(.)-1)))*100) %>%
  select(missing) %>%
  # plot the distribution of missing values
  ggplot(aes(x = missing)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
  labs(x = "Percentage of missing values", y = "Number of proteins") +
  theme_minimal()

```


```{r}
# calculae the percentage of missing values per sample
eset %>%
  exprs(.) %>%
  data.frame(.) %>%
  # convert missing values to 0 and valid values to 1
  mutate_all(~ifelse(is.na(.), 0, 1)) %>%
  # calculate the percentage of missing values per sample
  summarise(across(everything(), ~((sum(. == 0) / n()) * 100))) %>%
  gather(key = "sample", value = "missing") %>%
  arrange(desc(missing)) %>%
  # plot the distribution of missing values
  ggplot(aes(x = missing)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
  labs(x = "Percentage of missing values", y = "Number of samples") +
  theme_minimal()

```

### Differential expression analysis in LIMMA 

#### DE between conditions

This analysis does not consider time, which is likely to have an effect on protein expression. This is a preliminary analysis to identify proteins that are differentially expressed between conditions. A more comprehensive analysis will be performed later, considering both condition and time.

```{r}
# create directory for limma results
limma_dir <- here(data_dir, "03_limma")
dir.create(limma_dir, showWarnings = FALSE)
dir.create(here(limma_dir, "plots"), showWarnings = FALSE)
```

```{r linear model with limma: condition}
# Import eset
eset <- rio::import(here(preprocessing_dir, "eset.RDS"))

# Convert 'CONDITION', 'TIME' and 'FACTOR' to factors
eset$CONDITION <- as.factor(eset$CONDITION)
eset$TIME <- as.factor(eset$TIME)
eset$FACTOR <- as.factor(eset$FACTOR)

# Construct design matrix
design <- model.matrix(~0 + CONDITION, data = eset)
colnames(design) <- levels(eset$CONDITION)

# Define conditions for contrast matrix
contrasts <- list()

# Make contrasts of all conditions against each other
for (i in levels(eset$CONDITION)){
  for (j in levels(eset$CONDITION)){
    if (i != j){
      contrast_name <- paste(i, "vs", j, sep = "_")
      contrast <- paste(i, j, sep = " - ")
      contrasts[[contrast_name]] <- contrast}
  }
}

# Construct constrast matrix
contrast_matrix <- makeContrasts(contrasts = contrasts, levels = design)
colnames(contrast_matrix) <- names(contrasts)

# Define linear model
fit_C <- eset %>%
  # linear regression of every protein against designmatrix as covariable
  lmFit(design) %>%
  # include constrast matrix
  contrasts.fit(contrast_matrix) %>%
  # Empirical Bayes Statistics for Differential Expression
  eBayes

# Save limma results of each contrast in a list
results_C <- contrasts %>%
  # get vector of contrast names
  names() %>%
  # name each element in the vector with its own value
  set_names(.,.) %>%
  # create named list of results for each contrast
  purrr::map(function(coef, fit_C){
    topTable(fit_C, 
             coef = coef, 
             number = Inf)
  },
  fit = fit_C)
```

##### All conditions vs water blank
Look at all conditions against the blank (A):

```{r All conditions vs blank}
# all conditions vs blank
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep("[A-Z]_vs_A",
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC", "WORM"),
             FC = 2,
             treeheight_row = 0) %T>%
  save_pheatmap_png(.,filename = here(limma_dir, "plots", "HM_all_vs_blank.png"),
                    width = 16, height = 9, res = 300)

count_deregulated_proteins(top_proteins)
identify_deregulated_proteins(top_proteins, cutoff = 40, min_present = 30) %>%
  arrange(desc(present))
```
##### Dry worm vs dry worm blank
```{r Dry worm vs dry worm blank}
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep("[GKHL]_vs_B",
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC", "WORM"),
             FC = 2,
             title = "All conditions vs blank")

count_deregulated_proteins(top_proteins)
identify_deregulated_proteins(top_proteins, cutoff = 40, min_present = 30) %>%
  arrange(desc(present))
```
##### Live worm vs live worm blank
Look at live worm conditions vs live worm blanks - M, O, N, P vs F and Q

```{r Live worm vs live worm blank}
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep("[MNOP]_vs_[FQ]",
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC", "WORM"),
             FC = 2,
             title = "Live worm vs live worm blank",
             treeheight_row = 0)

count_deregulated_proteins(top_proteins)
identify_deregulated_proteins(top_proteins, cutoff = 40, min_present = 30) %>%
  arrange(desc(present))
```
##### Live worm vs dry worm

Look at conditions with live worms vs their respective dry worm counterparts:
- F vs B, M vs G, O vs K, N vs H, P vs L

```{r Live worm vs dry worm}
contrasts <- c("F_vs_B", "M_vs_G", "O_vs_K", "N_vs_H", "P_vs_L")
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC"),
             FC = 2,
             treeheight_row = 0) %T>%
  save_pheatmap_png(.,filename = here(limma_dir, "plots", "HM_live_vs_dry.png"),
                    width = 16, height = 9, res = 300)

count_deregulated_proteins(top_proteins)
count_deregulated_proteins(top_proteins, FC = 0) %>%
  summarise_all(sum)
identify_deregulated_proteins(top_proteins, cutoff = 40, min_present = 30) %>%
  arrange(desc(present))
```

##### Jasmonate vs jasmonate blanks
Look at conditions with jasmonate vs their respective jasmonate blanks:
- Q vs F, I vs D, K vs G, O vs M, J vs E, L vs H, P vs N
```{r Jasmonate vs jasmonate blanks}
contrasts <- c("Q_vs_F", "I_vs_D", "K_vs_G",
               "O_vs_M", "J_vs_E", "L_vs_H", "P_vs_N")
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("PLASTIC", "WORM"),
             FC = 2,
             treeheight_row = 0) %T>%
  save_pheatmap_png(.,filename = here(limma_dir, "plots", "HM_jasmonate_vs_blank.png"),
                    width = 16, height = 9, res = 300)

count_deregulated_proteins(top_proteins)
count_deregulated_proteins(top_proteins, FC = 0) %>%
  summarise_all(sum)
identify_deregulated_proteins(top_proteins, cutoff = 40, min_present = 30) %>%
  arrange(desc(present))

```
##### Worm vs no worm
Compare plastic containing conditions with worm to their respective worm free counterparts:
G vs D, K vs I, M vs D, O vs I, H vs E, L vs J, N vs E, P vs J

```{r Worm vs no worm}
contrasts <- c("G_vs_D", "K_vs_I", "M_vs_D", "O_vs_I",
               "H_vs_E", "L_vs_J", "N_vs_E", "P_vs_J")
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Organism, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC", "WORM"),
             FC = 2,
             title = "Worm vs no worm",
             treeheight_row = 0)

count_deregulated_proteins(top_proteins)

# count deregulation of proteins excluing worm associated proteins
top_proteins %>%
  filter(!grepl("tenebrio molitor", Organism, ignore.case=TRUE)) %>%
count_deregulated_proteins()

top_proteins %>%
  filter(!grepl("tenebrio molitor", Organism, ignore.case=TRUE)) %>%
  identify_deregulated_proteins(cutoff = 40, min_present = 30)
```
##### Plastic vs no plastic
Compare plastic containing conditions to their respective plastic free counterparts:
I vs C, G vs B, M vs F, O vs Q, J vs C, H vs B, N vs F, P vs Q\
D vs A, and E vs A are not analysed as no samples are available for conditions D and E.

```{r}
contrasts <- c("D_vs_A", "I_vs_C", "G_vs_B", "M_vs_F", "O_vs_Q",
               "E_vs_A", "J_vs_C", "H_vs_B", "N_vs_F", "P_vs_Q")
top_proteins <- topTable(fit_C,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit_C$coefficients))) %>% 
  select(Protein.ID, Organism, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("JASMONATE", "PLASTIC", "WORM"),
             FC = 2,
             treeheight_row = 0) %T>%
  save_pheatmap_png(.,filename = here(limma_dir, "plots", "HM_plastic_vs_nopalstic.png"),
                    width = 16, height = 9, res = 300)

count_deregulated_proteins(top_proteins) %>%
  mutate(influence = ifelse(up>down, "+", "-"))

count_deregulated_proteins(top_proteins) %>%
  summarise_all(sum)

identify_deregulated_proteins(top_proteins, cutoff = 70, min_present = 50)
```
#### DE between time points
Make a model of the form ~0 + TIME to compare the time points against each other.

```{r linear model with limma: time}
# Import eset
eset <- rio::import(here(preprocessing_dir, "eset.RDS"))

# Convert 'CONDITION', 'TIME' and 'FACTOR' to factors
eset$CONDITION <- as.factor(eset$CONDITION)
eset$TIME <- as.factor(eset$TIME)
eset$FACTOR <- as.factor(eset$FACTOR)

# Construct design matrix
design <- model.matrix(~0 + TIME, data = eset)
colnames(design) <- levels(eset$TIME)

# Define conditions for contrast matrix
contrasts <- list(
  "t1_vs_t0" = "t1 - t0",
  "t3_vs_t0" = "t3 - t0",
  "t5_vs_t0" = "t5 - t0",
  "t3_vs_t1" = "t3 - t1",
  "t5_vs_t1" = "t5 - t1",
  "t5_vs_t3" = "t5 - t3"
)

# Construct constrast matrix
contrast_matrix <- makeContrasts(contrasts = contrasts, levels = design)
colnames(contrast_matrix) <- names(contrasts)

# Define linear model
fit_T <- eset %>%
  # linear regression of every protein against designmatrix as covariable
  lmFit(design) %>%
  # include constrast matrix
  contrasts.fit(contrast_matrix) %>%
  # Empirical Bayes Statistics for Differential Expression
  eBayes

# Save limma results of each contrast in a list
results_T <- contrasts %>%
  # get vector contrast names
  names() %>%
  # name each element in the vector with its own value
  set_names(.,.) %>%
  # create named list of results for each contrast
  purrr::map(function(coef, fit_T){
    topTable(fit_T, 
             coef = coef, 
             number = Inf)
  },
  fit = fit_T)
```


```{r time comparison}
top_proteins <- topTable(fit_T,
                         number = Inf) %>% 
  select(Protein.ID, Organism, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             FC = 2,
             title = "Protein expression over time")

count_deregulated_proteins(top_proteins, FC = 2)
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 50, min_present = 30)
```

```{r volcano plots time comparison}
# Create volcano plots of time point comparison
names <- grep("_vs_", colnames(fit_T$coefficients), value = TRUE)

volcano_plots_T <- purrr::map(names, ~plot_volcano(results_T, .x)) %>%
  set_names(names)

purrr::walk(volcano_plots_T, print)
```
#### DE between conditions and time
```{r linear model with limma: condition and time}
# Import eset
eset <- rio::import(here(preprocessing_dir, "eset.RDS"))

# Convert 'CONDITION', 'TIME' and 'FACTOR' to factors
eset$CONDITION <- as.factor(eset$CONDITION)
eset$TIME <- as.factor(eset$TIME)
eset$FACTOR <- as.factor(eset$FACTOR)

# Construct design matrix
design <- model.matrix(~0 + FACTOR, data = eset)
# set names for the design matrix columns
colnames(design) <- levels(eset$FACTOR)


# Initiate contrast list
contrasts <- list()

# For each condition make contrast of time points: A_t1-A_t0, A_t3-A_t1, ...
# Loop through conditions
for (condition in levels(eset$CONDITION)){
  # initiate prev_factor as last factor in the condition
  # factors are in reverse order to get "later time point - earlier time point"
  prev_factor <- grep(condition, rev(levels(eset$FACTOR)), value = TRUE)[1]
  # loop through remaining factors of the condition and build contrasts
  for (factor in grep(condition, rev(levels(eset$FACTOR)), value = TRUE)[-1]){
    # Create contrast name and contrast
    contrast_name <- paste(prev_factor, "vs", factor, sep = "_")
    contrast <- paste(prev_factor, factor, sep = " - ")
    # Store contrast in the list
    contrasts[[contrast_name]] <- contrast
    # Update prev_factor
    prev_factor <- factor
  }
}

# For each time point make contrasts of factors: A_t1-B_t1, A_t1-C_t1, ...
# Loop through time points
for (t in levels(eset$TIME)){
  # Iterate through each combination of factors
  for(factor in grep(t, levels(eset$FACTOR), value = TRUE)){
    for (factor2 in grep(t, levels(eset$FACTOR), value = TRUE)){
      # Check if factors are not identical
      if (!identical(factor, factor2)){
        # Create contrast name and contrast
        contrast_name <- paste(substr(factor,1, 1), "vs", factor2, sep = "_")
        contrast <- paste(factor, factor2, sep = " - ")
        # Store contrast in the list
        contrasts[[contrast_name]] <- contrast
      }
    }
  }
}

# Construct constrast matrix
contrast_matrix <- makeContrasts(contrasts = contrasts, levels = design)
colnames(contrast_matrix) <- names(contrasts)

# Define linear model
fit <- eset %>%
  # linear regression of every protein against designmatrix as covariable
  lmFit(design) %>%
  # include constrast matrix
  contrasts.fit(contrast_matrix) %>%
  # Empirical Bayes Statistics for Differential Expression
  eBayes

# Save limma results of each contrast in a list
results <- contrasts %>%
  # get vector contrast names
  names() %>%
  # name each element in the vector with its own value
  set_names(.,.) %>%
  # create named list of results for each contrast
  purrr::map(function(coef, fit){
    topTable(fit, 
             coef = coef, 
             number = Inf)
  },
  fit = fit)

# Export limma results as Excel sheet
results %>%
  openxlsx::write.xlsx(here(limma_dir, "limma_results.xlsx"))
```

##### PCA of limma results

```{r limma_PCA}
# PCA of limma results
fit %>%
  topTable(., number = Inf) %>%
  # select contrasts only
  select(names(contrasts)) %>%
  # change NA to 0
  replace(is.na(.), 0) %>%
  # filter rows with all 0
  filter(!rowSums(.) == 0) %>%
  # filter columns with all 0
  select_if(~!all(. == 0)) %>%
  # transpose to have contrasts as rows
  t() %>%
  data.frame() %>%
  # perform PCA
  prcomp(., center = TRUE, scale. = TRUE) %>%
  # plot PCA
  autoplot(., x = 1, y = 2, loadings = FALSE) +
  ggtitle("PCA of limma results") +
  theme_classic()

ggsave(plot = last_plot(), here(limma_dir, "plots", "PCA_limma.png"),
            width = 13, height = 9, dpi = 300, units = "cm")
```
##### PET vs PET blank
Look at PET containing conditions (I, K, M, O) against the PET blank + jasmonate (G).
No samples of condition D (PET blank without jasmonate) were obtained.
HPLC results indicated best degradation in conditions following this order: O > M > K > I > D > G.\

```{r PET_vs_blank}
top_proteins_PET <- topTable(fit,
                             number = Inf,
                             coef = grep("[OMKI]_vs_G_t[0-5]",
                                         colnames(fit$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val, matches("_vs_"))

plot_heatmap(top_proteins_PET,
             annotation = c("TIME", "WORM", "JASMONATE"),
             treeheight_row = 0)

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins_PET, FC = 0)
count_deregulated_proteins(top_proteins_PET, FC = 0) %>%
  summarize_all(sum)
```

```{r volcano_plots_PET}
# Create volcano plots for PET conditions vs PET blank
names <- grep("[OMKI]_vs_G_t[0-5]", colnames(fit$coefficients), value = TRUE)

volcano_plots_PET <- purrr::map(names, ~plot_volcano(results, .x)) %>%
  set_names(names)

purrr::walk(volcano_plots_PET, print)
```
###### PET time difference

```{r PET_time}
top_proteins_PET_t <- topTable(fit,
                         number = Inf,
                         coef = grep("[OMKIGD]_t[0-5]_vs_[OMKIGD]_t[0-5]",
                                     colnames(fit$coefficients)),
                         lfc = 0.5) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins_PET_t,
             annotation = c("JASMONATE", "WORM", "TIME"),
             FC = 2,
             title = "PET time difference")

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins_PET_t, FC = 0)
count_deregulated_proteins(top_proteins_PET_t, FC = 0) %>%
  summarize_all(sum)
identify_deregulated_proteins(top_proteins_PET_t, cutoff = 50, min_present = 40)
```
##### PBAT vs PBAT blank
HPLC results indicated best degradation in conditions following this order: E > J > P > L > H > N.\
Unfortunately so samples of condition E are available for comparison.
Look at PBAT containing conditions (H, J, L) against H (dry worm) and N (PBAT and live worm).

```{r PBAT_vs_blank}
top_proteins_PBAT <- topTable(fit,
                         number = Inf,
                         coef = grep("[PJL]_vs_[HN]_t[0-5]",
                                     colnames(fit$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

top_proteins_PBAT %>% plot_heatmap(.,
             annotation = c("TIME", "WORM", "JASMONATE"),
             FC = 2,
             title = "PBAT vs blank")

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins, FC = 0)
count_deregulated_proteins(top_proteins, FC = 0) %>%
  summarize_all(sum)

# Which proteins are overexpressed?
identify_deregulated_proteins(top_proteins_PBAT,
                              cutoff = 0, min_present = 0) %>%
  arrange(desc(present))
# Which proteins are downregulated?
identify_deregulated_proteins(top_proteins_PBAT,
                              cutoff = 0, min_present = 0, DE = "down") %>%
  arrange(desc(present))
```
```{r volcano_plots_PBAT}
# Create volcano plots for PET conditions vs PET blank
names <- grep("[PJL]_vs_[HN]_t[0-5]",
              colnames(fit$coefficients), value = TRUE)

volcano_plots_PBAT <- purrr::map(names, ~plot_volcano(results, .x)) %>%
  set_names(names)

purrr::walk(volcano_plots_PBAT, print)
```

###### PBAT time difference
```{r PBAT_time}
top_proteins_PBAT_t <- topTable(fit,
                         number = Inf,
                         coef = grep("[HJLNPE]_t[0-5]_vs_[HJLNPE]_t[0-5]",
                                     colnames(fit$coefficients)),
                         lfc = 0.5) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins_PBAT_t,
             annotation = c("TIME", "WORM", "JASMONATE"),
             FC = 2,
             title = "PBAT time difference")

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins_PBAT_t, FC = 0)
count_deregulated_proteins(top_proteins_PBAT_t, FC = 0) %>%
  summarize_all(sum)

identify_deregulated_proteins(top_proteins_PBAT_t, cutoff = 40, min_present = 30)
```
##### Identify putative plastic degrading proteins
Extract the proteins that are overexpressed in PET and PBAT samples compared to the lowest plastic degrading conditions for each respective plastic.

Conditions O and M are the most promising for PET degradation, while conditions J and P are the most promising for PBAT degradation.\
These conditions are compared against their respective low plastic degrading conditions G, I and N, H.
D I and E do not contain worm, so to avoid only finding proteins which are overexpressed due to the presence of worm, I also include live worm conditions F and Q, which do not contain any plastic.
```{r most interesting proteins}

# list of uninteresting proteins to exclude
exclude <- c("actin", "ribosomal", "polymerase", "ATP synthase", "Ras", "Lpp",
             "chaperonin", "tubulin", "elongation", "transcription", "histone")

# create table with overexpressed proteins in promising conditions
topTable(fit,
         number = Inf,
         coef = grep("[OM]_vs_[GI]_t[0-5]|[JP]_vs_[NH]_t[0-5]",
                     colnames(fit$coefficients)),
         lfc = 0.5) %>%
  select(Protein.ID, Description, Organism, adj.P.Val, matches("_vs_")) %>%
  # filter out uninteresting proteins
  filter(!grepl(paste(exclude, collapse = "|"),
                Description, ignore.case = TRUE)) %>%
  # count number of overexpression per protein
  identify_deregulated_proteins(FC = 2, cutoff = 50, min_present = 50)
```
```{r}
topTable(fit,
         number = Inf,
         coef = grep("[OM]_vs_[FQ]_t[0-5]|[JP]_vs_[FQ]_t[0-5]",
                     colnames(fit$coefficients)),
         lfc = 0.5) %>%
  select(Protein.ID, Description, Organism, adj.P.Val, matches("_vs_")) %>%
  # filter out uninteresting proteins
  filter(!grepl(paste(exclude, collapse = "|"),
                Description, ignore.case = TRUE)) %>%
  identify_deregulated_proteins(FC = 2, cutoff = 40, min_present = 30)
```
Look at overexpression statistics when including both of the above comparisons:
```{r}
putative_degraders <- topTable(fit,
                               number = Inf,
                               coef = grep("[OM]_vs_[FQGI]_t|[JP]_vs_[FQNH]_t",
                                           colnames(fit$coefficients)),
         lfc = 0.5) %>%
  select(Protein.ID, Description, Organism, adj.P.Val, matches("_vs_")) %>%
  # filter out uninteresting proteins
  filter(!grepl(paste(exclude, collapse = "|"),
                Description, ignore.case = TRUE)) %>%
  # count number of overexpression per protein
  identify_deregulated_proteins(FC = 2, cutoff = 30, min_present = 30)

putative_degraders %T>%
  # Export to csv
  rio::export(here(limma_dir, "putative_degraders.csv"))
```
Are these proteins significantly overexpressed in the respective conditions?
```{r}
# extract Protein.IDs from putative plastic degraders
names <- putative_degraders$Protein.ID

contrasts <- putative_degraders %>%
  select(matches("_vs_")) %>%
  colnames()

putative_degraders_stats <- extract_pvalue(results, contrasts, names) 
putative_degraders_stats %>%
  filter(P.Value < 0.05)
```

##### Influence of Jasmonate
Comapare conditions:\
- PET: K vs G, O vs M, I vs D - PBAT: P vs N, L vs H, J vs E - No plastic: Q vs F

```{r jasmonate upregulation}
contrasts <- c("K_vs_G", "O_vs_M", "P_vs_N", "L_vs_H", "Q_vs_F")
top_proteins <- topTable(fit,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit$coefficients)),
                         lfc = 1) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("TIME", "WORM", "PLASTIC"),
             treeheight_row = 0) %T>%
  save_pheatmap_png(.,filename = here(limma_dir, "plots", "HM_jasmonate.png"),
                    width = 16, height = 9, res = 300)

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins)
count_deregulated_proteins(top_proteins) %>%
  summarise_all(sum)

# Look at upredulated proteins
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 50,
                              min_present = 40)
# Look at downregulated proteins
identify_deregulated_proteins(top_proteins, cutoff = 40, FC = 1,
                              min_present = 40, DE = "down") 

```

```{r volcano_plots_jasmonate}
# Create volcano plots for PBAT conditions comparing time points
names <- contrasts %>%
  paste(collapse = "|") %>%
  grep(., colnames(fit$coefficients), value = TRUE)

volcano_plots_jasmonate <- purrr::map(names, ~plot_volcano(results, .x)) %>%
  set_names(names)

purrr::walk(volcano_plots_jasmonate, print)
```

##### Plastic vs. no plastic
Compare plastic containing conditions to their respective plastic free counterparts:
- G vs B, M vs F, O vs Q, H vs B, N vs F, P vs Q, K vs B, L vs B
- Only conditions with worm are considered.
K and L (jasmonate containing dry worm PET and PBAT samples) were also compated to B as no dry worm blank with jasmonate was prepared.

```{r }
contrasts <- c("[GH]_vs_B_t[1-5]", "[KL]_vs_B_t[1-5]",
               "[MN]_vs_F_t[1-5]", "[OP]_vs_Q_t[1-5]")
top_proteins <- topTable(fit,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit$coefficients)),
                         lfc = 0.5) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("TIME", "PLASTIC", "WORM", "JASMONATE"),
             FC = 2,
             title = "Plastic vs no plastic")

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins, FC = 0)

count_deregulated_proteins(top_proteins, FC = 0) %>%
  summarise_all(sum)

# Identify proteins that are upregulated
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 50, min_present = 40)
# Identify downregulated proteins
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 50,
                              min_present = 40, DE = "down")
```
##### Dry worm vs dry worm blank
Look at all dry worm conditions (G, H, K, L) against the dry worm blank (B):
```{r dry_worm_vs_blank}
top_proteins <- topTable(fit,
                         number = Inf,
                         coef = grep("[GHKL]_vs_B_t[0-5]",
                                     colnames(fit$coefficients))) %>% 
  select(Protein.ID, Description, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("TIME", "PLASTIC", "JASMONATE"),
             FC = 2,
             title = "Sry worm vs dry worm blank")


# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins, FC = 0)
# make table of most overexpressed proteins in dry worm samples
identify_deregulated_proteins(top_proteins, cutoff = 50, min_present = 20)
```
##### Live worm vs live worm blank
Look at all live worm conditions (M, N, O, P) against the live worm blanks (F, Q):
```{r live_worm_vs_blank}
contrasts <- c("[MN]_vs_F_t[1-5]", "[OP]_vs_Q_t[1-5]")
top_proteins <- topTable(fit,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("TIME", "PLASTIC", "JASMONATE"),
             FC = 2,
             treeheight_row = 0)

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins, FC = 2)
# make table of most overexpressed proteins in dry worm samples
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 50, min_present = 40)

```
```{r volcano_plots_liveworm}
# Create volcano plots for PBAT conditions comparing time points
names <- grep("[MN]_vs_F_t[1-5]|[OP]_vs_Q_t[1-5]", colnames(fit$coefficients), value = TRUE)

volcano_plots_liveworm <- purrr::map(names, ~plot_volcano(results, .x)) %>%
  set_names(names)

purrr::walk(volcano_plots_liveworm, print)

```
##### Non-worm containing vs water blank
Look at conditions containing plastic but no worm (D, E, I, J) vs the water blanks (A and C):
```{r worm free vs water blank}
contrasts <- c("[DE]_vs_A_t[1-5]", "[IJ]_vs_C_t[1-5]")
top_proteins <- topTable(fit,
                         number = Inf,
                         coef = grep(paste(contrasts, collapse = "|"),
                                     colnames(fit$coefficients))) %>% 
  select(Protein.ID, Description, Organism, adj.P.Val ,matches("_vs_"))

plot_heatmap(top_proteins,
             annotation = c("TIME", "PLASTIC", "JASMONATE"),
             FC = 2,
             treeheight_row = 0)

# Create table with the number of deregulated proteins
count_deregulated_proteins(top_proteins, FC = 2)
# make table of most overexpressed proteins in dry worm samples
identify_deregulated_proteins(top_proteins, FC = 2, cutoff = 30, min_present = 30)
```

## Conclusion
Only few interesting observations could be made for the Sarracenia data.
This is most likely due to the non-fitting database that containes hydrolases, Nepenthes proteins and tenebrio molitor proteome, but barely any Sarracenia proteins.
Unfortunatels no Sarracenia proteins are available to this date (June 26. 2024) that could be integrated into the database.
Uniprot only lists about 200 proteins, which already were included in this search.

## Session info

```{r session info}
sessionInfo()
```
